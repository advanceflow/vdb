# -*- coding: utf-8 -*-
# @Time    : ${create_time}
# @Author  : auto-generated by TorchCMH

"""
    please finish with your algorithm
"""

# basic dependent
import torch
from torch.autograd import Variable
from tqdm import tqdm
from torch.utils.data import DataLoader
from torchcmh.training.base import TrainBase
from torchcmh.utils import calc_neighbor
from torchcmh.utils import calc_map_k

# special dependent
from torchcmh.models.${train_name} import *

# add your dependent
# ...

__all__ = ['train']


class ${train_name}(TrainBase):
    def __init__(self, data_name: str, img_dir: str, bit: int, img_net, visdom=True, batch_size=128, cuda=True,
                 **kwargs):
        super(${train_name}, self).__init__("${train_name}", data_name, bit, batch_size, visdom, cuda)
        # choose your dataloader
        self.train_data, self.valid_data =
        self.loss_store = []
        self.parameters = {}
        self.lr = {}
        self.max_epoch = 500

        # initialize variables
        # ...

        self.optimizers = []
        self._init()

    def train(self, num_works=4):
        train_loader = DataLoader(self.train_data, batch_size=self.batch_size, drop_last=True, num_workers=num_works,
                                  shuffle=False, pin_memory=True)
        for epoch in range(self.max_epoch):
            # finish your training code
            # ...

            # valid if you don't need valid, you can delete this line
            self.valid(epoch)

            self.lr_schedule()
            self.plotter.next_epoch()

    def valid(self, epoch):
        mapi2t, mapt2i, qB_img, qB_txt, rB_img, rB_txt = \
            self.valid_calc(self.img_model, self.txt_model, self.valid_data, self.bit, self.batch_size,
                            return_hash=True)
        # do something after calculated MAP


def train(dataset_name: str, img_dir: str, bit: int, visdom=True, batch_size=128, cuda=True,
          **kwargs):
    # do some check before running trainer
    # ...

    trainer = ${train_name}(dataset_name, img_dir, bit, img_net, visdom, batch_size, cuda, **kwargs)
    trainer.train()